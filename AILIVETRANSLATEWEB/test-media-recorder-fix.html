<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MediaRecorder Init Fix Test</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .status {
            padding: 10px;
            margin: 10px 0;
            border-radius: 4px;
            font-weight: bold;
        }
        .success { background-color: #d4edda; color: #155724; }
        .warning { background-color: #fff3cd; color: #856404; }
        .error { background-color: #f8d7da; color: #721c24; }
        .info { background-color: #d1ecf1; color: #0c5460; }
        button {
            background-color: #007bff;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            margin: 5px;
        }
        button:hover { background-color: #0056b3; }
        button:disabled { background-color: #6c757d; cursor: not-allowed; }
        .log {
            background-color: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            padding: 10px;
            height: 300px;
            overflow-y: auto;
            font-family: monospace;
            font-size: 12px;
            white-space: pre-wrap;
        }
        .test-section {
            margin: 20px 0;
            padding: 15px;
            border: 1px solid #dee2e6;
            border-radius: 4px;
        }
        .metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 10px;
            margin: 10px 0;
        }
        .metric {
            background-color: #f8f9fa;
            padding: 10px;
            border-radius: 4px;
            text-align: center;
        }
        .metric-value {
            font-size: 24px;
            font-weight: bold;
            color: #007bff;
        }
        .timeline {
            background-color: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            padding: 15px;
            margin: 10px 0;
        }
        .timeline-step {
            display: flex;
            align-items: center;
            margin: 5px 0;
            padding: 5px;
            border-radius: 4px;
        }
        .timeline-step.completed {
            background-color: #d4edda;
            color: #155724;
        }
        .timeline-step.waiting {
            background-color: #fff3cd;
            color: #856404;
        }
        .timeline-step.error {
            background-color: #f8d7da;
            color: #721c24;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ¯ MediaRecorder Init Fix Test</h1>
        <p>Ø§Ø®ØªØ¨Ø§Ø± Ø¥ØµÙ„Ø§Ø­ Ù…Ø´ÙƒÙ„Ø© ØªØ´ØºÙŠÙ„ MediaRecorder Ù‚Ø¨Ù„ ØªØ£ÙƒÙŠØ¯ Init</p>

        <div class="test-section">
            <h3>ğŸ“Š Ø­Ø§Ù„Ø© Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø±</h3>
            <div id="testStatus" class="status info">Ø¬Ø§Ù‡Ø² Ù„Ù„Ø§Ø®ØªØ¨Ø§Ø±</div>
            
            <div class="timeline">
                <h4>â±ï¸ ØªØ³Ù„Ø³Ù„ Ø§Ù„Ø£Ø­Ø¯Ø§Ø«</h4>
                <div id="timelineSteps">
                    <div class="timeline-step" id="step1">1. Ø¥Ù†Ø´Ø§Ø¡ WebSocket</div>
                    <div class="timeline-step" id="step2">2. Ø¥Ø±Ø³Ø§Ù„ Init</div>
                    <div class="timeline-step" id="step3">3. Ø§Ù†ØªØ¸Ø§Ø± Init Ack</div>
                    <div class="timeline-step" id="step4">4. ØªØ´ØºÙŠÙ„ MediaRecorder</div>
                    <div class="timeline-step" id="step5">5. Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„ØµÙˆØª</div>
                </div>
            </div>
        </div>

        <div class="test-section">
            <h3>ğŸ“Š Ø§Ù„Ù…Ù‚Ø§ÙŠÙŠØ³</h3>
            <div class="metrics">
                <div class="metric">
                    <div class="metric-value" id="wsConnected">âŒ</div>
                    <div>WebSocket Ù…ØªØµÙ„</div>
                </div>
                <div class="metric">
                    <div class="metric-value" id="initSent">âŒ</div>
                    <div>Init Ù…Ø±Ø³Ù„</div>
                </div>
                <div class="metric">
                    <div class="metric-value" id="initAcked">âŒ</div>
                    <div>Init Ù…Ø¤ÙƒØ¯</div>
                </div>
                <div class="metric">
                    <div class="metric-value" id="recorderStarted">âŒ</div>
                    <div>MediaRecorder Ù…Ø´ØºÙ„</div>
                </div>
                <div class="metric">
                    <div class="metric-value" id="audioSent">âŒ</div>
                    <div>ØµÙˆØª Ù…Ø±Ø³Ù„</div>
                </div>
            </div>
        </div>

        <div class="test-section">
            <h3>ğŸ® Ø§Ù„ØªØ­ÙƒÙ…</h3>
            <button id="startTestBtn" onclick="startTest()">ğŸš€ Ø¨Ø¯Ø¡ Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø±</button>
            <button id="stopTestBtn" onclick="stopTest()" disabled>â¹ï¸ Ø¥ÙŠÙ‚Ø§Ù Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø±</button>
            <button id="clearLogBtn" onclick="clearLog()">ğŸ—‘ï¸ Ù…Ø³Ø­ Ø§Ù„Ø³Ø¬Ù„Ø§Øª</button>
        </div>

        <div class="test-section">
            <h3>ğŸ“ Ø§Ù„Ø³Ø¬Ù„Ø§Øª</h3>
            <div id="log" class="log"></div>
        </div>

        <div class="test-section">
            <h3>ğŸ“Š Ø§Ù„Ù†ØªØ§Ø¦Ø¬</h3>
            <div class="metrics">
                <div class="metric">
                    <div class="metric-value" id="totalChunks">0</div>
                    <div>Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„Ù‚Ø·Ø¹</div>
                </div>
                <div class="metric">
                    <div class="metric-value" id="sentChunks">0</div>
                    <div>Ù‚Ø·Ø¹ Ù…Ø±Ø³Ù„Ø©</div>
                </div>
                <div class="metric">
                    <div class="metric-value" id="queuedChunks">0</div>
                    <div>Ù‚Ø·Ø¹ Ù…Ø®Ø²Ù†Ø©</div>
                </div>
                <div class="metric">
                    <div class="metric-value" id="testDuration">0s</div>
                    <div>Ù…Ø¯Ø© Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø±</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        let ws = null;
        let mediaRecorder = null;
        let audioStream = null;
        let isTestRunning = false;
        let isInitAcknowledged = false;
        let totalChunks = 0;
        let sentChunks = 0;
        let queuedChunks = 0;
        let testStartTime = 0;

        function log(message) {
            const logElement = document.getElementById('log');
            const timestamp = new Date().toLocaleTimeString();
            logElement.textContent += `[${timestamp}] ${message}\n`;
            logElement.scrollTop = logElement.scrollHeight;
            console.log(message);
        }

        function clearLog() {
            document.getElementById('log').textContent = '';
        }

        function updateStatus(message, type = 'info') {
            const statusElement = document.getElementById('testStatus');
            statusElement.className = `status ${type}`;
            statusElement.textContent = message;
        }

        function updateStep(stepNumber, status) {
            const stepElement = document.getElementById(`step${stepNumber}`);
            stepElement.className = `timeline-step ${status}`;
            
            if (status === 'completed') {
                stepElement.innerHTML = `${stepNumber}. ${stepElement.textContent.split('. ')[1]} âœ…`;
            } else if (status === 'waiting') {
                stepElement.innerHTML = `${stepNumber}. ${stepElement.textContent.split('. ')[1]} â³`;
            } else if (status === 'error') {
                stepElement.innerHTML = `${stepNumber}. ${stepElement.textContent.split('. ')[1]} âŒ`;
            }
        }

        function updateMetrics() {
            document.getElementById('wsConnected').textContent = ws && ws.readyState === WebSocket.OPEN ? 'âœ…' : 'âŒ';
            document.getElementById('initSent').textContent = ws && ws.readyState === WebSocket.OPEN ? 'âœ…' : 'âŒ';
            document.getElementById('initAcked').textContent = isInitAcknowledged ? 'âœ…' : 'âŒ';
            document.getElementById('recorderStarted').textContent = mediaRecorder && mediaRecorder.state === 'recording' ? 'âœ…' : 'âŒ';
            document.getElementById('audioSent').textContent = sentChunks > 0 ? 'âœ…' : 'âŒ';
            
            document.getElementById('totalChunks').textContent = totalChunks;
            document.getElementById('sentChunks').textContent = sentChunks;
            document.getElementById('queuedChunks').textContent = queuedChunks;
            
            if (testStartTime > 0) {
                const duration = Math.floor((Date.now() - testStartTime) / 1000);
                document.getElementById('testDuration').textContent = `${duration}s`;
            }
        }

        async function startTest() {
            if (isTestRunning) {
                log('âš ï¸ Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø± Ù‚ÙŠØ¯ Ø§Ù„ØªØ´ØºÙŠÙ„ Ø¨Ø§Ù„ÙØ¹Ù„');
                return;
            }

            log('ğŸš€ Ø¨Ø¯Ø¡ Ø§Ø®ØªØ¨Ø§Ø± MediaRecorder Init Fix...');
            isTestRunning = true;
            testStartTime = Date.now();
            totalChunks = 0;
            sentChunks = 0;
            queuedChunks = 0;
            isInitAcknowledged = false;
            
            updateStatus('Ø¨Ø¯Ø¡ Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø±...', 'info');
            document.getElementById('startTestBtn').disabled = true;
            document.getElementById('stopTestBtn').disabled = false;

            try {
                // Step 1: Ø¥Ù†Ø´Ø§Ø¡ WebSocket
                log('ğŸ“¡ Ø¥Ù†Ø´Ø§Ø¡ WebSocket...');
                updateStep(1, 'waiting');
                
                ws = new WebSocket('wss://ai-voicesum.onrender.com/ws');
                
                ws.onopen = async () => {
                    log('âœ… WebSocket Ù…ØªØµÙ„ Ø¨Ù†Ø¬Ø§Ø­');
                    updateStep(1, 'completed');
                    updateMetrics();
                    
                    // Step 2: Ø¥Ø±Ø³Ø§Ù„ Init
                    log('ğŸ“¤ Ø¥Ø±Ø³Ø§Ù„ Ø±Ø³Ø§Ù„Ø© Init...');
                    updateStep(2, 'waiting');
                    
                    const initMessage = {
                        type: 'init',
                        language: 'auto',
                        targetLanguage: 'en',
                        clientSideTranslation: true,
                        realTimeMode: true,
                        autoDetection: true,
                        audioConfig: {
                            sampleRate: 16000,
                            channels: 1,
                            bitsPerSample: 16,
                            encoding: 'pcm_s16le'
                        }
                    };
                    
                    ws.send(JSON.stringify(initMessage));
                    log('ğŸ“¤ Init message sent:', JSON.stringify(initMessage, null, 2));
                    updateStep(2, 'completed');
                    updateMetrics();
                    
                    // Step 3: Ø§Ù†ØªØ¸Ø§Ø± Init Ack
                    log('â³ Ø§Ù†ØªØ¸Ø§Ø± ØªØ£ÙƒÙŠØ¯ Init...');
                    updateStep(3, 'waiting');
                    
                    // Ø§Ù†ØªØ¸Ø§Ø± ØªØ£ÙƒÙŠØ¯ init Ø£Ùˆ Ù…Ù‡Ù„Ø© Ø²Ù…Ù†ÙŠØ©
                    let initWaitAttempts = 0;
                    const maxInitWaitAttempts = 50; // 5 seconds
                    
                    while (initWaitAttempts < maxInitWaitAttempts && !isInitAcknowledged) {
                        await new Promise(resolve => setTimeout(resolve, 100));
                        initWaitAttempts++;
                        log(`â³ Ø§Ù†ØªØ¸Ø§Ø± Init Ack... (${initWaitAttempts}/${maxInitWaitAttempts})`);
                    }
                    
                    if (isInitAcknowledged) {
                        log('âœ… Init acknowledged, proceeding to MediaRecorder...');
                        updateStep(3, 'completed');
                        updateMetrics();
                        
                        // Step 4: ØªØ´ØºÙŠÙ„ MediaRecorder
                        await startMediaRecorder();
                    } else {
                        log('âš ï¸ Init acknowledgment timeout, proceeding anyway...');
                        updateStep(3, 'error');
                        updateMetrics();
                        
                        // ØªØ´ØºÙŠÙ„ MediaRecorder Ø­ØªÙ‰ Ù„Ùˆ Ø§Ù†ØªÙ‡Øª Ø§Ù„Ù…Ù‡Ù„Ø©
                        await startMediaRecorder();
                    }
                };

                ws.onmessage = (event) => {
                    try {
                        const data = JSON.parse(event.data);
                        log(`ğŸ“¨ Ø±Ø³Ø§Ù„Ø© Ù…Ø³ØªÙ„Ù…Ø©: ${JSON.stringify(data, null, 2)}`);
                        
                        if (data.type === 'init_ack') {
                            log('âœ… Init acknowledgment received!');
                            isInitAcknowledged = true;
                            updateStep(3, 'completed');
                            updateMetrics();
                        } else if (data.type === 'ready' || data.type === 'initialized') {
                            log('âœ… Server ready message received');
                            isInitAcknowledged = true;
                            updateStep(3, 'completed');
                            updateMetrics();
                        } else if (data.type === 'error') {
                            log(`âŒ Server error: ${data.message}`);
                        }
                    } catch (error) {
                        log(`âŒ Error parsing message: ${error}`);
                    }
                };

                ws.onclose = (event) => {
                    log(`ğŸ”Œ WebSocket Ù…ØºÙ„Ù‚: ${event.code} - ${event.reason}`);
                    updateStatus('WebSocket connection closed', 'error');
                    stopTest();
                };

                ws.onerror = (error) => {
                    log(`âŒ WebSocket error: ${error}`);
                    updateStatus('WebSocket connection error', 'error');
                    stopTest();
                };

            } catch (error) {
                log(`âŒ Error starting test: ${error}`);
                updateStatus('Error starting test', 'error');
                stopTest();
            }
        }

        async function startMediaRecorder() {
            try {
                log('ğŸ¤ Ø¨Ø¯Ø¡ MediaRecorder...');
                updateStep(4, 'waiting');
                
                // Ø·Ù„Ø¨ Ø¥Ø°Ù† Ø§Ù„Ù…ÙŠÙƒØ±ÙˆÙÙˆÙ†
                audioStream = await navigator.mediaDevices.getUserMedia({ 
                    audio: {
                        sampleRate: 16000,
                        channelCount: 1,
                        echoCancellation: true,
                        noiseSuppression: true,
                        autoGainControl: true
                    } 
                });
                
                log('âœ… Microphone access granted');
                
                // Ø¥Ù†Ø´Ø§Ø¡ MediaRecorder
                mediaRecorder = new MediaRecorder(audioStream, {
                    mimeType: 'audio/webm;codecs=opus'
                });
                
                mediaRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0) {
                        totalChunks++;
                        log(`ğŸ“¦ Audio chunk received: ${event.data.size} bytes`);
                        
                        // âœ… Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø­Ø§Ù„Ø© Ø§Ù„ØªØ£ÙƒÙŠØ¯ Ù‚Ø¨Ù„ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„ØµÙˆØª
                        if (ws && ws.readyState === WebSocket.OPEN && isInitAcknowledged) {
                            log('âœ… Init acknowledged, sending audio chunk');
                            sentChunks++;
                            
                            // Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„ØµÙˆØª
                            const reader = new FileReader();
                            reader.onload = () => {
                                const base64Audio = reader.result.split(',')[1];
                                const audioMessage = {
                                    type: 'audio',
                                    data: base64Audio,
                                    format: 'audio/webm;codecs=opus'
                                };
                                
                                ws.send(JSON.stringify(audioMessage));
                                log(`ğŸ“¤ Audio chunk sent: ${event.data.size} bytes`);
                                updateStep(5, 'completed');
                                updateMetrics();
                            };
                            reader.readAsDataURL(event.data);
                        } else {
                            log('âš ï¸ Init not acknowledged yet, queuing audio chunk');
                            queuedChunks++;
                            updateMetrics();
                        }
                    }
                };
                
                mediaRecorder.onstart = () => {
                    log('âœ… MediaRecorder started successfully');
                    updateStep(4, 'completed');
                    updateMetrics();
                };
                
                mediaRecorder.onstop = () => {
                    log('ğŸ›‘ MediaRecorder stopped');
                };
                
                mediaRecorder.onerror = (event) => {
                    log(`âŒ MediaRecorder error: ${event}`);
                    updateStep(4, 'error');
                };
                
                // ØªØ´ØºÙŠÙ„ MediaRecorder
                mediaRecorder.start(1000); // 1 second intervals
                
            } catch (error) {
                log(`âŒ Error starting MediaRecorder: ${error}`);
                updateStep(4, 'error');
                updateStatus('Error starting MediaRecorder', 'error');
            }
        }

        function stopTest() {
            log('â¹ï¸ Ø¥ÙŠÙ‚Ø§Ù Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø±...');
            isTestRunning = false;
            
            if (mediaRecorder && mediaRecorder.state === 'recording') {
                mediaRecorder.stop();
            }
            
            if (audioStream) {
                audioStream.getTracks().forEach(track => track.stop());
            }
            
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.close(1000, 'Test completed');
            }
            
            document.getElementById('startTestBtn').disabled = false;
            document.getElementById('stopTestBtn').disabled = true;
            updateStatus('Test completed', 'success');
            updateMetrics();
        }

        // Update metrics every second
        setInterval(updateMetrics, 1000);

        // Initialize
        log('ğŸš€ MediaRecorder Init Fix Test ready');
        log('ğŸ’¡ Press "Ø¨Ø¯Ø¡ Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø±" to start the test');
    </script>
</body>
</html> 