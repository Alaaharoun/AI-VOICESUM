<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Server Diagnosis Tool</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .test-section {
            margin: 20px 0;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 5px;
        }
        .success { color: #28a745; }
        .error { color: #dc3545; }
        .warning { color: #ffc107; }
        .info { color: #17a2b8; }
        button {
            background: #007bff;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            margin: 5px;
        }
        button:hover {
            background: #0056b3;
        }
        .log {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 4px;
            padding: 10px;
            font-family: monospace;
            font-size: 12px;
            max-height: 300px;
            overflow-y: auto;
            white-space: pre-wrap;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üîß Server Diagnosis Tool</h1>
        <p>This tool will help diagnose connection issues with your WebSocket servers.</p>
        
        <div class="test-section">
            <h2>üì° Server Endpoints Test</h2>
            <button onclick="testAllServers()">Test All Servers</button>
            <button onclick="testRenderServer()">Test Render Server Only</button>
            <button onclick="clearLogs()">Clear Logs</button>
            <div id="serverResults" class="log"></div>
        </div>

        <div class="test-section">
            <h2>üîå WebSocket Connection Test</h2>
            <button onclick="testWebSocketConnections()">Test WebSocket Connections</button>
            <button onclick="testRenderWebSocket()">Test Render WebSocket Only</button>
            <div id="wsResults" class="log"></div>
        </div>

        <div class="test-section">
            <h2>üåê Network Diagnostics</h2>
            <button onclick="performNetworkDiagnostics()">Run Network Diagnostics</button>
            <div id="networkResults" class="log"></div>
        </div>
    </div>

    <script>
        const SERVER_CONFIG = {
            RENDER: {
                name: 'Render WebSocket Server',
                wsUrl: 'wss://ai-voicesum.onrender.com/ws',
                httpUrl: 'https://ai-voicesum.onrender.com/transcribe',
                healthUrl: 'https://ai-voicesum.onrender.com/health',
                engine: 'azure'
            },
            HUGGING_FACE: {
                name: 'Hugging Face Spaces',
                wsUrl: '',
                httpUrl: 'https://alaaharoun-faster-whisper-api.hf.space/transcribe',
                healthUrl: 'https://alaaharoun-faster-whisper-api.hf.space/health',
                engine: 'faster-whisper'
            },
            LOCAL: {
                name: 'Local Development',
                wsUrl: 'ws://localhost:7860/ws',
                httpUrl: 'http://localhost:7860/transcribe',
                healthUrl: 'http://localhost:7860/health',
                engine: 'faster-whisper'
            }
        };

        function log(elementId, message, type = 'info') {
            const element = document.getElementById(elementId);
            const timestamp = new Date().toLocaleTimeString();
            const className = type === 'success' ? 'success' : 
                             type === 'error' ? 'error' : 
                             type === 'warning' ? 'warning' : 'info';
            
            element.innerHTML += `<span class="${className}">[${timestamp}] ${message}</span>\n`;
            element.scrollTop = element.scrollHeight;
        }

        function clearLogs() {
            document.getElementById('serverResults').innerHTML = '';
            document.getElementById('wsResults').innerHTML = '';
            document.getElementById('networkResults').innerHTML = '';
        }

        async function testAllServers() {
            log('serverResults', 'üß™ Starting comprehensive server test...', 'info');
            
            for (const [key, config] of Object.entries(SERVER_CONFIG)) {
                await testServer(config);
            }
            
            log('serverResults', '‚úÖ Server testing completed', 'success');
        }

        async function testRenderServer() {
            log('serverResults', 'üîç Testing Render Server specifically...', 'info');
            await testServer(SERVER_CONFIG.RENDER);
        }

        async function testServer(config) {
            log('serverResults', `\nüîç Testing ${config.name}...`, 'info');
            
            // Test health endpoint
            if (config.healthUrl) {
                try {
                    log('serverResults', `  üì° Health check: ${config.healthUrl}`, 'info');
                    const startTime = Date.now();
                    
                    const response = await fetch(config.healthUrl, {
                        method: 'GET',
                        headers: { 'Content-Type': 'application/json' }
                    });
                    
                    const duration = Date.now() - startTime;
                    
                    if (response.ok) {
                        log('serverResults', `  ‚úÖ Health check passed (${response.status}, ${duration}ms)`, 'success');
                        
                        try {
                            const data = await response.text();
                            log('serverResults', `  üìÑ Response: ${data}`, 'info');
                        } catch (e) {
                            log('serverResults', `  üìÑ Response: (binary data)`, 'info');
                        }
                    } else {
                        log('serverResults', `  ‚ùå Health check failed: ${response.status} - ${response.statusText}`, 'error');
                    }
                } catch (error) {
                    log('serverResults', `  ‚ùå Health check error: ${error.message}`, 'error');
                }
            }
            
            // Test HTTP endpoint
            if (config.httpUrl) {
                try {
                    log('serverResults', `  üì° HTTP check: ${config.httpUrl}`, 'info');
                    const startTime = Date.now();
                    
                    const response = await fetch(config.httpUrl, {
                        method: 'OPTIONS'
                    });
                    
                    const duration = Date.now() - startTime;
                    
                    if (response.ok) {
                        log('serverResults', `  ‚úÖ HTTP endpoint accessible (${response.status}, ${duration}ms)`, 'success');
                    } else {
                        log('serverResults', `  ‚ö†Ô∏è HTTP endpoint returned: ${response.status} - ${response.statusText}`, 'warning');
                    }
                } catch (error) {
                    log('serverResults', `  ‚ùå HTTP endpoint error: ${error.message}`, 'error');
                }
            }
        }

        async function testWebSocketConnections() {
            log('wsResults', 'üß™ Starting WebSocket connection test...', 'info');
            
            for (const [key, config] of Object.entries(SERVER_CONFIG)) {
                if (config.wsUrl) {
                    await testWebSocket(config);
                }
            }
            
            log('wsResults', '‚úÖ WebSocket testing completed', 'success');
        }

        async function testRenderWebSocket() {
            log('wsResults', 'üîç Testing Render WebSocket specifically...', 'info');
            await testWebSocket(SERVER_CONFIG.RENDER);
        }

        async function testWebSocket(config) {
            if (!config.wsUrl) {
                log('wsResults', `\n‚ö†Ô∏è ${config.name}: No WebSocket URL configured`, 'warning');
                return;
            }
            
            log('wsResults', `\nüîå Testing WebSocket: ${config.name}`, 'info');
            log('wsResults', `  üì° URL: ${config.wsUrl}`, 'info');
            
            try {
                const startTime = Date.now();
                const ws = new WebSocket(config.wsUrl);
                
                const result = await new Promise((resolve) => {
                    let resolved = false;
                    
                    const timeout = setTimeout(() => {
                        if (!resolved) {
                            resolved = true;
                            ws.close();
                            resolve({ success: false, error: 'Connection timeout (5s)' });
                        }
                    }, 5000);
                    
                    ws.onopen = () => {
                        if (!resolved) {
                            resolved = true;
                            clearTimeout(timeout);
                            const duration = Date.now() - startTime;
                            
                            // Send test message
                            const testMessage = {
                                type: 'ping',
                                timestamp: Date.now()
                            };
                            
                            ws.send(JSON.stringify(testMessage));
                            log('wsResults', `  üì§ Sent test ping message`, 'info');
                            
                            // Wait a bit for potential response
                            setTimeout(() => {
                                ws.close();
                                resolve({ success: true, duration });
                            }, 1000);
                        }
                    };
                    
                    ws.onerror = (error) => {
                        if (!resolved) {
                            resolved = true;
                            clearTimeout(timeout);
                            resolve({ success: false, error: error.type || 'WebSocket error' });
                        }
                    };
                    
                    ws.onclose = (event) => {
                        log('wsResults', `  üîå WebSocket closed: Code ${event.code}, Reason: ${event.reason || 'No reason'}`, 'info');
                    };
                    
                    ws.onmessage = (event) => {
                        log('wsResults', `  üì® Received message: ${event.data}`, 'success');
                    };
                });
                
                if (result.success) {
                    log('wsResults', `  ‚úÖ WebSocket connection successful (${result.duration}ms)`, 'success');
                } else {
                    log('wsResults', `  ‚ùå WebSocket connection failed: ${result.error}`, 'error');
                }
                
            } catch (error) {
                log('wsResults', `  ‚ùå WebSocket test error: ${error.message}`, 'error');
            }
        }

        async function performNetworkDiagnostics() {
            log('networkResults', 'üåê Starting network diagnostics...', 'info');
            
            // Check browser capabilities
            log('networkResults', '\nüîç Browser Capabilities:', 'info');
            log('networkResults', `  WebSocket support: ${typeof WebSocket !== 'undefined' ? '‚úÖ Yes' : '‚ùå No'}`, 'info');
            log('networkResults', `  Fetch support: ${typeof fetch !== 'undefined' ? '‚úÖ Yes' : '‚ùå No'}`, 'info');
            log('networkResults', `  MediaRecorder support: ${typeof MediaRecorder !== 'undefined' ? '‚úÖ Yes' : '‚ùå No'}`, 'info');
            
            // Check connection info
            if (navigator.connection) {
                log('networkResults', `  Connection type: ${navigator.connection.effectiveType || 'Unknown'}`, 'info');
                log('networkResults', `  Downlink: ${navigator.connection.downlink || 'Unknown'} Mbps`, 'info');
            }
            
            // Test basic connectivity
            log('networkResults', '\nüåê Basic Connectivity Test:', 'info');
            
            const testUrls = [
                'https://www.google.com',
                'https://httpbin.org/get',
                'https://api.github.com'
            ];
            
            for (const url of testUrls) {
                try {
                    const startTime = Date.now();
                    const response = await fetch(url, { 
                        method: 'HEAD',
                        mode: 'no-cors'
                    });
                    const duration = Date.now() - startTime;
                    log('networkResults', `  ‚úÖ ${url}: Reachable (${duration}ms)`, 'success');
                } catch (error) {
                    log('networkResults', `  ‚ùå ${url}: ${error.message}`, 'error');
                }
            }
            
            // Test CORS
            log('networkResults', '\nüîí CORS Test:', 'info');
            try {
                const response = await fetch('https://httpbin.org/get');
                log('networkResults', `  ‚úÖ CORS test passed`, 'success');
            } catch (error) {
                log('networkResults', `  ‚ùå CORS test failed: ${error.message}`, 'error');
            }
            
            log('networkResults', '\n‚úÖ Network diagnostics completed', 'success');
        }

        // Auto-run basic tests on page load
        document.addEventListener('DOMContentLoaded', () => {
            log('serverResults', 'üîß Server Diagnosis Tool Ready', 'info');
            log('serverResults', 'Click "Test All Servers" to start comprehensive testing', 'info');
        });
    </script>
</body>
</html> 