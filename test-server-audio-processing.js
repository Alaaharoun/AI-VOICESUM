const WebSocket = require('ws');
const https = require('https');

class ServerAudioProcessingTest {
  constructor() {
    this.testResults = {
      serverHealth: false,
      websocketConnection: false,
      audioProcessing: false,
      azureSpeechService: false,
      errors: []
    };
  }
  
  async log(message, type = 'info') {
    const timestamp = new Date().toLocaleTimeString();
    const icon = {
      info: '‚ÑπÔ∏è',
      success: '‚úÖ',
      error: '‚ùå',
      warning: '‚ö†Ô∏è'
    }[type] || '‚ÑπÔ∏è';
    
    console.log(`${icon} [${timestamp}] ${message}`);
  }
  
  async testServerHealth() {
    await this.log('üì° ŸÅÿ≠ÿµ ÿµÿ≠ÿ© ÿßŸÑÿ≥Ÿäÿ±ŸÅÿ±...', 'info');
    
    try {
      const healthResponse = await new Promise((resolve, reject) => {
        const req = https.get('https://ai-voicesum.onrender.com/health', (res) => {
          let data = '';
          res.on('data', chunk => data += chunk);
          res.on('end', () => {
            try {
              const healthData = JSON.parse(data);
              this.log('‚úÖ Server Health:', 'success');
              console.log('   Status:', healthData.status);
              console.log('   API Key:', healthData.apiKey);
              console.log('   Timestamp:', healthData.timestamp);
              
              this.testResults.serverHealth = true;
              this.testResults.azureSpeechService = healthData.apiKey === 'Present';
              
              resolve(healthData);
            } catch (e) {
              this.log('‚ö†Ô∏è Health response not JSON:', 'warning');
              console.log('   Raw response:', data);
              this.testResults.serverHealth = true;
              resolve({ status: 'ok', response: data });
            }
          });
        });
        
        req.on('error', reject);
        req.setTimeout(10000, () => {
          req.destroy();
          reject(new Error('Health check timeout'));
        });
      });
      
      return true;
      
    } catch (error) {
      this.log(`‚ùå Server health check failed: ${error.message}`, 'error');
      return false;
    }
  }
  
  async testWebSocketWithDetailedLogging() {
    await this.log('üîå ÿßÿÆÿ™ÿ®ÿßÿ± WebSocket ŸÖÿπ ÿ™ÿ≥ÿ¨ŸäŸÑ ŸÖŸÅÿµŸÑ...', 'info');
    
    try {
      const ws = new WebSocket('wss://ai-voicesum.onrender.com/ws');
      
      const result = await new Promise((resolve, reject) => {
        const timeout = setTimeout(() => {
          this.log('‚è∞ WebSocket connection timeout', 'error');
          ws.close();
          reject(new Error('WebSocket timeout'));
        }, 15000);
        
        ws.on('open', () => {
          this.log('‚úÖ WebSocket connected', 'success');
          clearTimeout(timeout);
          this.testResults.websocketConnection = true;
          
          // Send init message
          setTimeout(() => {
            const initMessage = {
              type: 'init',
              language: 'ar-SA',
              autoDetection: false,
              realTime: true
            };
            
            this.log('üì§ Sending init message...', 'info');
            ws.send(JSON.stringify(initMessage));
            
            // Send test audio after 2 seconds
            setTimeout(() => {
              this.log('üéµ Sending test audio...', 'info');
              
              // Create test audio (1 second of silence)
              const audioBuffer = Buffer.alloc(32000, 0);
              const base64Data = audioBuffer.toString('base64');
              
              const audioMessage = {
                type: 'audio',
                data: base64Data,
                format: 'audio/pcm'
              };
              
              ws.send(JSON.stringify(audioMessage));
              this.log(`üì§ Sent audio: ${audioBuffer.length} bytes`, 'info');
              
              // Monitor for responses
              let messageCount = 0;
              ws.on('message', (data) => {
                messageCount++;
                this.log(`üì• Message ${messageCount} received`, 'info');
                
                try {
                  const message = JSON.parse(data.toString());
                  this.log(`   Type: ${message.type}`, 'info');
                  
                  if (message.type === 'transcription' || message.type === 'final') {
                    this.log(`   Text: "${message.text}"`, 'success');
                    this.testResults.audioProcessing = true;
                  } else if (message.type === 'error') {
                    this.log(`   Error: ${message.error}`, 'error');
                    this.testResults.errors.push(message.error);
                  } else if (message.type === 'status') {
                    this.log(`   Status: ${message.message}`, 'info');
                  } else {
                    this.log(`   Content: ${JSON.stringify(message)}`, 'info');
                  }
                  
                } catch (parseError) {
                  this.log(`   Raw data: ${data.toString().substring(0, 100)}`, 'info');
                }
              });
              
              // Close after 10 seconds
              setTimeout(() => {
                this.log('üîÑ Closing connection...', 'info');
                ws.close();
                resolve(true);
              }, 10000);
              
            }, 2000);
            
          }, 1000);
        });
        
        ws.on('error', (error) => {
          this.log(`‚ùå WebSocket error: ${error.message}`, 'error');
          clearTimeout(timeout);
          reject(error);
        });
        
        ws.on('close', (code, reason) => {
          this.log(`üîí WebSocket closed: ${code} - ${reason}`, 'info');
          clearTimeout(timeout);
          resolve(false);
        });
      });
      
      return result;
      
    } catch (error) {
      this.log(`‚ùå WebSocket test failed: ${error.message}`, 'error');
      return false;
    }
  }
  
  async testDifferentAudioFormats() {
    await this.log('üéµ ÿßÿÆÿ™ÿ®ÿßÿ± ÿ™ŸÜÿ≥ŸäŸÇÿßÿ™ ÿµŸàÿ™Ÿäÿ© ŸÖÿÆÿ™ŸÑŸÅÿ©...', 'info');
    
    const formats = [
      { name: 'PCM Silence', data: Buffer.alloc(32000, 0), format: 'audio/pcm' },
      { name: 'PCM Noise', data: Buffer.alloc(32000, 65), format: 'audio/pcm' }, // 'A' character
      { name: 'PCM Sine Wave', data: this.generateSineWave(440, 1), format: 'audio/pcm' }
    ];
    
    for (const format of formats) {
      await this.log(`üéµ ÿßÿÆÿ™ÿ®ÿßÿ± ${format.name}...`, 'info');
      
      try {
        const ws = new WebSocket('wss://ai-voicesum.onrender.com/ws');
        
        const result = await new Promise((resolve) => {
          const timeout = setTimeout(() => {
            this.log(`‚è∞ ${format.name} test timeout`, 'warning');
            ws.close();
            resolve(false);
          }, 10000);
          
          ws.on('open', () => {
            this.log(`‚úÖ Connected for ${format.name} test`, 'success');
            
            setTimeout(() => {
              const initMessage = {
                type: 'init',
                language: 'ar-SA',
                autoDetection: false,
                realTime: true
              };
              
              ws.send(JSON.stringify(initMessage));
              this.log(`üì§ Sent init for ${format.name}`, 'info');
              
              setTimeout(() => {
                const base64Data = format.data.toString('base64');
                const audioMessage = {
                  type: 'audio',
                  data: base64Data,
                  format: format.format
                };
                
                ws.send(JSON.stringify(audioMessage));
                this.log(`üì§ Sent ${format.name}: ${format.data.length} bytes`, 'info');
                
                let responseReceived = false;
                ws.on('message', (data) => {
                  try {
                    const message = JSON.parse(data.toString());
                    if (message.type === 'transcription' || message.type === 'final') {
                      this.log(`‚úÖ ${format.name} transcription: "${message.text}"`, 'success');
                      responseReceived = true;
                    } else if (message.type === 'error') {
                      this.log(`‚ùå ${format.name} error: ${message.error}`, 'error');
                    }
                  } catch (e) {
                    // Ignore parse errors
                  }
                });
                
                setTimeout(() => {
                  clearTimeout(timeout);
                  ws.close();
                  resolve(responseReceived);
                }, 5000);
                
              }, 2000);
            }, 1000);
          });
          
          ws.on('error', (error) => {
            this.log(`‚ùå ${format.name} WebSocket error: ${error.message}`, 'error');
            clearTimeout(timeout);
            resolve(false);
          });
          
          ws.on('close', () => {
            clearTimeout(timeout);
            resolve(false);
          });
        });
        
        if (result) {
          this.log(`‚úÖ ${format.name} test successful`, 'success');
        } else {
          this.log(`‚ùå ${format.name} test failed`, 'error');
        }
        
      } catch (error) {
        this.log(`‚ùå ${format.name} test error: ${error.message}`, 'error');
      }
    }
  }
  
  generateSineWave(frequency, duration) {
    const sampleRate = 16000;
    const samples = duration * sampleRate;
    const buffer = Buffer.alloc(samples * 2); // 16-bit samples
    
    for (let i = 0; i < samples; i++) {
      const sample = Math.sin(2 * Math.PI * frequency * i / sampleRate);
      const value = Math.floor(sample * 32767); // Convert to 16-bit
      buffer.writeInt16LE(value, i * 2);
    }
    
    return buffer;
  }
  
  async runServerTest() {
    console.log('üîç === ÿßÿÆÿ™ÿ®ÿßÿ± ŸÖÿπÿßŸÑÿ¨ÿ© ÿßŸÑÿµŸàÿ™ ÿπŸÑŸâ ÿßŸÑÿ≥Ÿäÿ±ŸÅÿ± ===\n');
    
    try {
      // 1. Test server health
      const healthOk = await this.testServerHealth();
      if (!healthOk) {
        console.log('‚ùå Server health check failed. Stopping.', 'error');
        return false;
      }
      
      // 2. Test WebSocket with detailed logging
      const wsOk = await this.testWebSocketWithDetailedLogging();
      
      // 3. Test different audio formats
      await this.testDifferentAudioFormats();
      
      // Display final results
      console.log('\nüìä === ÿßŸÑŸÜÿ™ÿßÿ¶ÿ¨ ÿßŸÑŸÜŸáÿßÿ¶Ÿäÿ© ===');
      console.log(`üì° Server Health: ${this.testResults.serverHealth ? '‚úÖ PASS' : '‚ùå FAIL'}`);
      console.log(`üîå WebSocket: ${this.testResults.websocketConnection ? '‚úÖ PASS' : '‚ùå FAIL'}`);
      console.log(`üéµ Audio Processing: ${this.testResults.audioProcessing ? '‚úÖ PASS' : '‚ùå FAIL'}`);
      console.log(`üîë Azure Speech Service: ${this.testResults.azureSpeechService ? '‚úÖ Present' : '‚ùå Missing'}`);
      
      if (this.testResults.errors.length > 0) {
        console.log('\n‚ùå Server Errors:');
        this.testResults.errors.forEach(error => {
          console.log(`  - ${error}`);
        });
      }
      
      // Analysis
      console.log('\nüîç === ÿ™ÿ≠ŸÑŸäŸÑ ÿßŸÑŸÖÿ¥ŸÉŸÑÿ© ===');
      
      if (!this.testResults.azureSpeechService) {
        console.log('‚ùå ÿßŸÑŸÖÿ¥ŸÉŸÑÿ© ÿßŸÑÿ±ÿ¶Ÿäÿ≥Ÿäÿ©: Azure Speech Service ÿ∫Ÿäÿ± ŸÖŸèŸÅÿπŸëŸÑ');
        console.log('üí° ÿßŸÑÿ≠ŸÑ: ÿ™ÿ£ŸÉÿØ ŸÖŸÜ ÿ™ÿπŸäŸäŸÜ ŸÖÿ™ÿ∫Ÿäÿ±ÿßÿ™ ÿßŸÑÿ®Ÿäÿ¶ÿ© AZURE_SPEECH_KEY Ÿà AZURE_SPEECH_REGION');
      } else if (!this.testResults.audioProcessing) {
        console.log('‚ùå ÿßŸÑŸÖÿ¥ŸÉŸÑÿ©: Azure Speech Service ŸÖŸèŸÅÿπŸëŸÑ ŸÑŸÉŸÜ ŸÑÿß ŸäÿπÿßŸÑÿ¨ ÿßŸÑÿµŸàÿ™');
        console.log('üí° ÿßŸÑÿ£ÿ≥ÿ®ÿßÿ® ÿßŸÑŸÖÿ≠ÿ™ŸÖŸÑÿ©:');
        console.log('  1. ŸÖÿ¥ŸÉŸÑÿ© ŸÅŸä ÿ™ŸÜÿ≥ŸäŸÇ ÿßŸÑÿµŸàÿ™ ÿßŸÑŸÖÿ±ÿ≥ŸÑ');
        console.log('  2. ŸÖÿ¥ŸÉŸÑÿ© ŸÅŸä ÿ•ÿπÿØÿßÿØÿßÿ™ ÿßŸÑŸÑÿ∫ÿ©');
        console.log('  3. ŸÖÿ¥ŸÉŸÑÿ© ŸÅŸä Azure Speech Service ŸÜŸÅÿ≥Ÿá');
        console.log('  4. ŸÖÿ¥ŸÉŸÑÿ© ŸÅŸä ŸÖÿπÿßŸÑÿ¨ÿ© ÿßŸÑÿµŸàÿ™ ÿπŸÑŸâ ÿßŸÑÿ≥Ÿäÿ±ŸÅÿ±');
      } else {
        console.log('‚úÖ ŸÉŸÑ ÿ¥Ÿäÿ° ŸäÿπŸÖŸÑ ÿ®ÿ¥ŸÉŸÑ ÿµÿ≠Ÿäÿ≠!');
      }
      
      return this.testResults.audioProcessing;
      
    } catch (error) {
      console.log(`‚ùå Server test failed: ${error.message}`, 'error');
      return false;
    }
  }
}

// ÿ™ÿ¥ÿ∫ŸäŸÑ ÿßŸÑÿßÿÆÿ™ÿ®ÿßÿ±
async function main() {
  const test = new ServerAudioProcessingTest();
  
  try {
    const success = await test.runServerTest();
    process.exit(success ? 0 : 1);
  } catch (error) {
    console.error('‚ùå Test execution failed:', error);
    process.exit(1);
  }
}

if (require.main === module) {
  main();
}

module.exports = { ServerAudioProcessingTest }; 